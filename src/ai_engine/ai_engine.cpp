#include "ai_engine.h"
#include <iostream>
#include <sstream>
#include <iomanip>
#include "../core/crypto_helper.h" // For hashing and signing (placeholder)
#include <chrono>

AIEngine::AIEngine() : rng(std::chrono::steady_clock::now().time_since_epoch().count()) {}



std::pair<AIEngine::ProofOfComputation, double> AIEngine::run_inference_and_prove(const std::string& data_input) {
    // Simulate AI inference
    std::uniform_real_distribution<> dist(0.1, 10.0); // Simulate a compute score
    double score = dist(rng) * (1 + data_input.length() / 100.0); // Longer input, potentially higher score


    // Simulate output (e.g., a simple string representation of the score)
    std::stringstream ss;
    ss << std::fixed << std::setprecision(5) << score;
    std::string output_data = ss.str();

    // Generate proof components
    std::string data_hash = CryptoHelper::sha256(data_input);
    std::string output_hash = CryptoHelper::sha256(output_data);
    // The proof signature is generated by the validator when creating the transaction
    // For now, we'll leave it empty and assume the transaction will handle signing.
    // For now, we'll use a dummy public key for the compute provider.
    // In a real scenario, this would come from the validator's identity.
    static CryptoHelper::ECKeyPtr computeProviderPrivateKey = CryptoHelper::generateKeyPair();
    std::string public_key = CryptoHelper::getPublicKeyHex(computeProviderPrivateKey);
    std::string message_to_sign = data_hash + output_hash + public_key;
    std::string signature = CryptoHelper::signMessage(computeProviderPrivateKey, message_to_sign);

    std::cout << "AIEngine: Running inference for data (length " << data_input.length() << ") and got score: " << score << std::endl;

    std::string computation_id = generate_computation_id(data_input, "default_model"); // Assuming a default model for now

    return {{data_hash, output_hash, signature, public_key, computation_id}, score};
}


    // In a real scenario, this would involve loading an ONNX model,
    // processing data_input, and performing actual inference.
    // For demonstration, we'll return a random score based on input length.


std::string AIEngine::generate_computation_id(const std::string& data_input, const std::string& model_id) {
    // Combine data_input and model_id to create a unique ID
    // In a real system, this might involve more complex logic or a UUID generator
    return CryptoHelper::sha256(data_input + model_id + std::to_string(std::chrono::steady_clock::now().time_since_epoch().count()));
}

bool AIEngine::verify_proof(const std::string& data_input, double expected_score, const ProofOfComputation& proof) {
    // 1. Verify the data hash
    std::string data_hash_check = CryptoHelper::sha256(data_input);
    if (data_hash_check != proof.data_hash) {
        std::cerr << "AIEngine: Data hash mismatch during verification." << std::endl;
        return false;
    }

    // 2. Simulate re-running the AI computation to get the output and its hash.
    // In a real system, this would involve re-executing the model or a light client verification.
    // For this simulation, we'll assume the expected_score is what the re-computation would yield.
    // Therefore, we re-create the output_hash based on the expected_score.
    std::stringstream ss;
    ss << std::fixed << std::setprecision(5) << expected_score;
    std::string recomputed_output_data = ss.str();
    std::string recomputed_output_hash = CryptoHelper::sha256(recomputed_output_data);

    if (recomputed_output_hash != proof.output_hash) {
        std::cerr << "AIEngine: Recomputed output hash mismatch during verification." << std::endl;
        return false;
    }

    // 3. Verify the signature using the original data hash and the recomputed output hash
    std::string message_to_verify = proof.data_hash + recomputed_output_hash + proof.public_key;
    if (!CryptoHelper::verifySignature(proof.public_key, proof.signature, message_to_verify)) {
        std::cerr << "AIEngine: Signature verification failed." << std::endl;
        return false;
    }

    std::cout << "AIEngine: Proof verified successfully for data (length " << data_input.length() << ")" << std::endl;
    return true;
}
    // In a real system, this would involve re-running the computation
    // or verifying a cryptographic proof of computation.
    // For now, a simple check against a threshold or a re-computation simulation.
    // This is a placeholder for actual verifiable computation.


